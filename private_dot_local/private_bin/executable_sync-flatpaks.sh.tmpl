#!/bin/bash
set -euo pipefail

FLATPAKS_FILE="{{ .chezmoi.sourceDir }}/.chezmoidata/flatpaks.yaml"

if [ ! -f "$FLATPAKS_FILE" ]; then
    echo "Error: $FLATPAKS_FILE not found"
    exit 1
fi

# Get currently installed flatpaks with their remotes
mapfile -t INSTALLED < <(flatpak list --app --columns=application,origin)

# Parse YAML to get desired flatpaks per remote
declare -A DESIRED
while IFS= read -r line; do
    if [[ $line =~ ^[[:space:]]*-[[:space:]]+(.+)$ ]]; then
        app="${BASH_REMATCH[1]}"
        DESIRED["$current_remote:$app"]=1
    elif [[ $line =~ ^[[:space:]]*([a-zA-Z0-9_-]+):[[:space:]]*$ ]]; then
        current_remote="${BASH_REMATCH[1]}"
    fi
done < "$FLATPAKS_FILE"

# Install missing flatpaks from YAML
for key in "${!DESIRED[@]}"; do
    IFS=: read -r remote app <<< "$key"
    if ! printf '%s\n' "${INSTALLED[@]}" | grep -q "^${app}[[:space:]]"; then
        echo "Installing $app from $remote..."
        flatpak install -y "$remote" "$app" || echo "Failed to install $app"
    fi
done

# Update YAML with any newly installed flatpaks
declare -A REMOTES
for entry in "${INSTALLED[@]}"; do
    read -r app remote <<< "$entry"
    REMOTES["$remote"]+="    - $app"$'\n'
done

# Rebuild YAML file
{
    echo "flatpaks:"
    for remote in $(printf '%s\n' "${!REMOTES[@]}" | sort); do
        echo "  $remote:"
        echo "${REMOTES[$remote]}"
    done
} > "$FLATPAKS_FILE"

echo "Flatpak synchronization complete"
